#include <stdio.h>

/*
  1. 要想计算出 (0, 0) 到 (m, n) 且经过 (p, q) 点最短路径的条数，可以先计算
     出 (0, 0) 到 (p, q) 最短路径的条数，再计算出 (p, q) 到 (m, n) 的最短
     路径条数，之后将两者相乘。
     设：
        x = (0, 0) 到 (p, q) 最短路径的条数
        y = (p, q) 到 (m, n) 最短路径的条数
        路径条数为 result = x * y
     计算 y 时有一个技巧，可以将其转变为从 (0, 0) 出发到 (m - p, n - q) 的最
     短路径条数问题。
  2. 打印出所有最短路径中，纵坐标的和最小的那条路径。
     这也是一个技巧，可以简称为`贴地板走`
    
                                (m, n)
                                  |
                                 ...
                                  |
                (p, q) —————————(m, q)
                   |
                  ...
                   |
     (0, 0) ————(p, 0)
 */

// -------------------- 这一部分如果了解动态规划的话可以提交 ----------------
/*
  从 (0, 0) 出发到 (m, n) 的最短路径条数问题是一个 dp 问题
  到达 dp[i, j] 的路径条数 = dp[i - 1, j] + dp[i, j - 1]
  初始化 dp[m + 1][n + 1] 表示为 dp[0][0] 到 dp[m][n] 最短路径条数
  结果：dp[m][n]
 */
int dp(int m, int n) {
    int dp[m + 1][n + 1];
    // 归零
    for (int i = 0; i <= m; i++)
        for (int j = 0; j <= n; j++)
            dp[i][j] = 0;
    // 初始化
    for (int i = 0; i <= m; i++) dp[i][0] = 1;
    for (int i = 0; i <= n; i++) dp[0][i] = 1;

    for (int i = 1; i <= m; i++) {
        for (int j = 1; j <= n; j ++) {
            dp[i][j] = dp[i - 1][j] + dp[i][j - 1];
        }
    }

    return dp[m][n];
}
// -------------------- 这一部分如果了解动态规划的话可以提交 ----------------

int main() {
    int m = 2, n = 1, p = 1, q = 0;
    int x = dp(p, q), y = dp(m - p, n - q);
    printf("%d\n", x * y);

    // (0, 0)(1, 0)(2, 0)(2, 1)
    // 打印贴地板走即可
    // (0, 0) -> (p, 0)
    for (int i = 0; i < p; i++) {
        printf("(%d, %d)", i, 0);
    }
    // (p, 0) -> (p, q)
    for (int i = 0; i < q; i++) {
        printf("(%d, %d)", p, i);
    }
    // (p, q) -> (m, q)
    for (int i = p; i < m; i++) {
        printf("(%d, %d)", i, q);
    }
    // (m, q) -> (m, n)
    for (int i = q; i <= n; i++) {
        printf("(%d, %d)", m, i);
    }
    return 0;
}